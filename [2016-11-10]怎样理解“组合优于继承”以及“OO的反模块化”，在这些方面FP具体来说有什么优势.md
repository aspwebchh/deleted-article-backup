# 怎样理解“组合优于继承”以及“OO的反模块化”，在这些方面FP具体来说有什么优势？

不是继承优与组合， 而是多用组合少用继承，因为继承使的不到家代码容易出问题。

使用继承是有语义的的依赖的， 当子类继承父类时， 意味着子类和父类在抽相层面必须是要相同的，也是就所谓的IS - A关系。这种关系很难把控， 尤其层次多且复杂的继承结构 ，要保持结构中所有类之间的语意清楚一致是相当困难的。  而且如果要对位于继承结构上端的类作较大的改动，如改变和扩展类本身的语义，那结构中下层的类的意义也会一并改变，而这改变并非写代码时的本意。 当然可以可以实行接口隔离的方法再次分解继承结构 ，然而这是危险且耗费时间的工作， 并且会使整个继随结构变的更复杂。 因此， 在面向对象程序设计有一点原则是：多用结合少用继承 。 因为继承不但依赖目标类的功能， 而且还依赖它的语义， 而组合是依赖功能不依赖语义。 为什么Java语言在设计时去除了c++的多重继承功能， 规定一个字类只能继承一个父类， 因为滥用继承会使代码变的复杂，单继承已经能使问题变的不可控， 更何况多继承。 如果使用继承光只是奔着复用代码去的， 那绝对是一个错误的设计决策。

至于OO的的反模块化， 似乎从来没有听到过这样的理论。类是实现面向对象中第一要素， 是很好的模块化工具， OO的反模块化又从何说起？

FP程序设计和面象对象程序设计理念上虽然有所不同， 但绝对不会起冲突的。
FP编程有几个要点

- 声明性编程，也就是功能都是以表达式形式呈现
- 变量的值不可变，状态不可变
- 不关注代码的执行顺序
- 控制流使用函数调用和递归来实现
- 把函数当成程序设计的第一个素

而面向对象中主要的编程单元类和对象， 一些重要的原则如

- 单一职责，包、类、函数、变量这些编程单元在自身的层面要保持功能的单一性
- 开放封闭，对程序要的功能更新要以增加扩展的形式进行， 而非修改原来的旧的代码
- Liskov替换，少执行抽像类到具体类这种编程方式，保持同类形的类在相互替换时不出问题
- 依赖倒转， 尽量针对抽像编程
- 接口隔离 ，不从父类继承用的不到东西到子类
- 还有如高内聚低耦合，封闭变化 ，多用组少用继承等等

这些面象对象的要义都与FP编程方式没有半分瓜葛， 两者完全可以融合在一起使用，面象对象关注的是写代码的宏观设计，而FP更关注的是微观的细节实现。 如果非要说FP编程与传统编程理念不一致，那只能让面向过程出来背锅了。

现在主流平台上的高端编程语言如JVM中的scala， CLR的F#都是面向对象和FP结合的，或者说是FP为主， 面向对象为辅。 而C#和Java则是面向对象为主FP辅。顺便吐槽一下Java，在FP编程上，8中的lambda和集合操作要多难用就有多难用，根本没法和C#的linq比。   

可能是由于FP编程比普通的面向过程来的难学， 且主流编程语言都是在发展的后期才开始支持FP编程的， 行业环境就那样， FP编程市场占有率低也在情理之中。